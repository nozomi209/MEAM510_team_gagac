# Vive 自动导航功能完整说明

## 📋 目录

- [功能概述](#功能概述)
- [系统架构](#系统架构)
- [支持的模式](#支持的模式)
- [快速开始](#快速开始)
- [配置说明](#配置说明)
- [工作原理](#工作原理)
- [比赛任务对应](#比赛任务对应)
- [调试与监控](#调试与监控)
- [故障排除](#故障排除)
- [进阶配置](#进阶配置)

---

## 🎯 功能概述

本项目实现了基于Vive追踪器的完整自动导航系统，主要功能包括：

1. **Vive位置追踪**：实时获取机器人的精确位置和朝向角度
2. **自动导航**：基于Vive坐标自动导航到指定目标点
3. **多模式支持**：壁障跟随、单点导航、序列导航、手动控制
4. **障碍物避让**：结合ToF传感器实现安全导航
5. **序列导航**：自动依次访问多个位置（满足比赛要求）

---

## 🏗️ 系统架构

### 硬件连接

```
Vive基站 → [Vive追踪器1/2] → Servant板 (ESP32)
                                      ↓ UART
                                   Owner板 (ESP32)
                                      ↓ ToF传感器
                                    控制输出
```

### 数据流

```
servant板 (gagac-2.ino)
  ├─ 读取Vive追踪器数据（前后两个）
  ├─ 计算中心位置和朝向角度
  └─ 每100ms通过UART发送到Owner板
      格式: "VIVE:x.xx,y.yy,a.aa\n"

owner板 (owner-4.ino)
  ├─ 接收并解析Vive数据
  ├─ 读取ToF传感器数据（前、右前、右后）
  ├─ 根据模式执行导航逻辑
  └─ 发送控制命令到Servant板
      格式: "F<speed>", "L<rate>", "R<rate>", "S"
```

### 文件结构

```
owner-4/
├── owner-4.ino           # 主控制程序（模式切换、命令处理）
├── behavior-vive.ino     # Vive导航逻辑（目标点导航、障碍物避让）
├── behavior-wall.ino     # 壁障跟随逻辑（右墙跟随）
├── tof-3.ino            # ToF传感器读取
└── README_VIVE_NAV.md   # 本文档
```

---

## 🎮 支持的模式

### 模式概览

| 模式代码 | 模式名称 | 说明 | 比赛任务对应 |
|---------|---------|------|-------------|
| `W` | 壁障跟随模式 | 使用ToF传感器跟随右墙 | 部分支持完整一圈 |
| `R` | 导航到红色目标 | 自动导航到配置的红色目标点 | 自定义目标点 |
| `B` | 导航到蓝色目标 | 自动导航到配置的蓝色目标点 | 自定义目标点 |
| `V` | **3位置序列导航** | 自动依次访问3个位置 | ✅ **9分任务** |
| `M` | 手动模式 | 通过Web界面手动控制 | 手动任务 |

### 模式详细说明

#### 1. 壁障跟随模式 (`W`)

- **功能**：使用ToF传感器自动跟随右墙
- **启动方式**：串口发送 `W`
- **特点**：
  - 自动保持与右墙8cm距离
  - 遇到前方障碍物自动转向
  - 适合在封闭环境中自主移动

#### 2. 单点导航模式 (`R`, `B`)

- **功能**：自动导航到指定Vive坐标点
- **启动方式**：
  - `R` - 导航到红色目标点
  - `B` - 导航到蓝色目标点
- **特点**：
  - 基于Vive坐标精确导航
  - 30秒超时保护
  - 到达目标后自动停止并切换回壁障跟随

#### 3. **3位置序列导航模式 (`V`)** ⭐

- **功能**：自动依次访问3个Vive位置（**比赛要求：9分**）
- **启动方式**：串口发送 `V`
- **执行流程**：
  1. 导航到位置1（30秒超时，3分）
  2. 到达后自动导航到位置2（30秒超时，3分）
  3. 到达后自动导航到位置3（30秒超时，3分）
  4. 全部完成后自动切换回壁障跟随模式
- **特点**：
  - 每个位置独立30秒超时计时
  - 超时后自动切换到下一个位置
  - 完成所有位置后自动停止
  - 实时显示当前位置（1/3, 2/3, 3/3）和剩余时间

#### 4. 手动模式 (`M`)

- **功能**：通过Web界面或串口手动控制
- **启动方式**：串口发送 `M`
- **特点**：
  - 停止所有自动行为
  - 可通过Web界面控制移动
  - 适合精确操作和调试

---

## 🚀 快速开始

### 1. 硬件连接

确保以下连接正确：

- **UART连接**：
  - Owner板 GPIO18 (RX) ← Servant板 GPIO17 (TX)
  - Owner板 GPIO17 (TX) → Servant板 GPIO18 (RX)
- **Vive追踪器**：
  - Servant板 GPIO18 - 前追踪器
  - Servant板 GPIO19 - 后追踪器
- **ToF传感器**（Owner板）：
  - 前传感器（粉色）
  - 右前传感器（绿色）
  - 右后传感器（蓝色）

### 2. 配置目标点坐标

在 `owner-4.ino` 中修改目标点坐标（单位：mm）：

```cpp
// 单点导航目标
const float TARGET_RED_X = 2000.0;   // 红色目标X坐标
const float TARGET_RED_Y = 2000.0;   // 红色目标Y坐标
const float TARGET_BLUE_X = 6000.0;  // 蓝色目标X坐标
const float TARGET_BLUE_Y = 2000.0;  // 蓝色目标Y坐标

// 3位置序列导航目标（位置1、2、3）
const float TARGET_RED_X = 2000.0;   // 位置1 X坐标
const float TARGET_RED_Y = 2000.0;   // 位置1 Y坐标
const float TARGET_BLUE_X = 6000.0;  // 位置2 X坐标
const float TARGET_BLUE_Y = 2000.0;  // 位置2 Y坐标
const float TARGET_LOC3_X = 4000.0;  // 位置3 X坐标
const float TARGET_LOC3_Y = 4000.0;  // 位置3 Y坐标
```

**⚠️ 重要**：根据实际的Vive坐标系和目标位置设置这些值。

### 3. 启动系统

1. 上电Servant板和Owner板
2. 等待Vive系统同步（约5秒）
3. 通过串口发送模式命令：
   - 发送 `V` 启动3位置序列导航
   - 发送 `W` 启动壁障跟随
   - 发送 `R` 或 `B` 导航到单个目标点

---

## ⚙️ 配置说明

### 目标点坐标配置

在 `owner-4.ino` 中配置：

```cpp
// 单点导航目标（R和B模式使用）
const float TARGET_RED_X = 2000.0;
const float TARGET_RED_Y = 2000.0;
const float TARGET_BLUE_X = 6000.0;
const float TARGET_BLUE_Y = 2000.0;

// 3位置序列导航目标（V模式使用）
// 位置1：使用 TARGET_RED_X/Y
// 位置2：使用 TARGET_BLUE_X/Y
// 位置3：使用 TARGET_LOC3_X/Y
const float TARGET_LOC3_X = 4000.0;
const float TARGET_LOC3_Y = 4000.0;
```

### 导航参数配置

在 `behavior-vive.ino` 中调整：

```cpp
const float ANGLE_TOLERANCE = 20.0f;      // 角度容差（度）
                                         // 角度误差>此值时先转向
const float DISTANCE_TOLERANCE = 5.0f;    // 到达距离阈值（mm）
                                         // 距离<此值时认为到达目标
```

### 超时设置

在 `owner-4.ino` 中配置：

```cpp
const unsigned long AUTO_NAV_TIMEOUT = 30000;  // 30秒超时（毫秒）
                                               // 每个位置30秒限制
```

### 速度控制

在 `behavior-vive.ino` 的 `gotoPoint()` 函数中调整：

```cpp
float speed = 50.0f;  // 基础速度
if (distance < 50.0f) {
    speed = 30.0f;    // 接近目标时减速
} else if (distance < 100.0f) {
    speed = 40.0f;
}
```

---

## 🔧 工作原理

### 1. Vive数据获取

**Servant板 (`gagac-2.ino`)**：
- 读取前后两个Vive追踪器的位置数据
- 计算机器人中心位置：`(前位置 + 后位置) / 2`
- 计算朝向角度：根据前后位置计算角度
- 每100ms通过UART发送到Owner板

**数据格式**：
```
VIVE:1234.56,2345.67,45.0
       ↑       ↑      ↑
      X坐标   Y坐标  角度
```

### 2. 自动导航算法

导航流程（在 `behavior-vive.ino` 中实现）：

```
1. 计算到目标点的距离和方向
   ├─ 距离 = √((ΔX)² + (ΔY)²)
   └─ 方向角 = atan2(ΔY, ΔX) + 90°

2. 检查是否到达目标
   └─ 距离 < DISTANCE_TOLERANCE (5mm) → 到达

3. 如果未到达，执行导航：
   ├─ 角度误差 > ANGLE_TOLERANCE (20°)
   │  └─ 先转向目标方向（L或R命令）
   └─ 角度误差 <= ANGLE_TOLERANCE
      └─ 向目标前进（F命令）

4. 结合ToF传感器避障
   ├─ 前方障碍物 < 150mm → 紧急停车
   └─ 前方障碍物 < 300mm → 转向避让
```

### 3. 3位置序列导航逻辑

序列导航流程（在 `owner-4.ino` 中实现）：

```
启动V模式
  ↓
currentLocationIndex = 0  (位置1)
autoNavStartTime = 当前时间
  ↓
[循环导航到位置1]
  ├─ 30秒内到达 → currentLocationIndex++，开始位置2
  └─ 30秒超时 → currentLocationIndex++，开始位置2
  ↓
[循环导航到位置2]
  ├─ 30秒内到达 → currentLocationIndex++，开始位置3
  └─ 30秒超时 → currentLocationIndex++，开始位置3
  ↓
[循环导航到位置3]
  ├─ 30秒内到达 → 完成，切换回壁障跟随
  └─ 30秒超时 → 完成，切换回壁障跟随
```

### 4. 障碍物避让

结合ToF传感器数据：

```cpp
// 紧急停车阈值
if (前方距离 < 150mm || 右前距离 < 80mm) {
    停止
}

// 避让逻辑
if (正在前进 && 前方距离 < 300mm) {
    根据左右空间选择转向方向
}
```

---

## 🏆 比赛任务对应

### ✅ 已实现的任务

#### 1. Autonomous cover 3 vive locations - **9 pts**

- **模式**：`V` 模式
- **要求**：
  - 自动访问3个Vive位置
  - 每个位置30秒内完成（3分/位置）
  - 共9分
- **实现状态**：✅ **完全实现**
- **使用方法**：
  1. 配置3个位置的Vive坐标
  2. 串口发送 `V` 启动
  3. 系统自动依次访问3个位置

### ⚠️ 部分支持的任务

#### 2. Autonomous full circuit wall follow - 10 pts

- **模式**：`W` 模式
- **要求**：
  - 完整跟随墙壁一圈
  - 1分钟内完成
  - 部分完成按比例给分
- **实现状态**：⚠️ **部分支持**
- **现有功能**：
  - ✅ 壁障跟随功能完整
  - ❌ 缺少一圈完成检测
- **建议改进**：
  - 记录起点Vive坐标
  - 检测是否回到起点（距离<阈值）
  - 一圈完成后自动停止

#### 3. Manual attack to tower/nexus - 3 pts

- **模式**：`M` 模式
- **要求**：手动控制攻击塔或Nexus
- **实现状态**：⚠️ **部分支持**
- **现有功能**：
  - ✅ 手动控制模式
  - ✅ Web界面控制
  - ❌ 缺少明确的"攻击"动作命令
- **建议改进**：
  - 如果硬件支持，添加攻击命令
  - 在Web界面添加攻击按钮

---

## 📊 调试与监控

### 串口输出信息

系统会定期输出详细状态信息：

#### 单点导航模式 (`R`, `B`)
```
Mode: 1 | Auto: ON | Vive: X=2500.0, Y=1800.0, A=45.0° | ToF: F=500, R1=200, R2=180
Starting auto navigation to RED target
RED target reached!
```

#### 3位置序列导航模式 (`V`)
```
Mode: 3LOCS | Loc: 1/3 | Time: 5000/30000 ms | Auto: ON | Vive: X=2500.0, Y=1800.0, A=45.0° | ToF: F=500, R1=200, R2=180
Starting navigation to Location 1 (X=2000.0, Y=2000.0)
Location 1 reached! (2000.0, 2000.0) - Time: 8500 ms
Starting navigation to Location 2 (X=6000.0, Y=2000.0)
...
All 3 locations completed successfully!
```

#### 模式说明

- **Mode**: 
  - `0` = 壁障跟随
  - `1` = 红色目标
  - `2` = 蓝色目标
  - `3` = 手动模式
  - `4` = 3位置序列（显示为3LOCS）
- **Auto**: `ON`/`OFF` - 自动模式开关状态
- **Vive**: 当前Vive坐标和角度
- **ToF**: 三个ToF传感器的距离值（单位：mm）
- **Loc**: 当前访问的位置（仅3位置序列模式）
- **Time**: 当前位置已用时间/超时时间（仅3位置序列模式）

### Web界面监控

通过Servant板的Web界面（http://192.168.4.1）可以：
- 查看实时Vive坐标（X, Y, Angle）
- 手动控制机器人移动
- 切换Vive追踪开关
- 控制自动模式开关

---

## 🔍 故障排除

### 问题1：Vive数据无效

**症状**：
- 串口显示Vive坐标为0或不变
- 自动导航模式自动降级为壁障跟随

**检查清单**：
1. ✅ 检查Servant板是否正确发送Vive数据
   - 查看Servant板串口输出，应该有 `📍 VIVE: X=...` 的信息
2. ✅ 检查UART连接
   - Owner板 GPIO18 ← Servant板 GPIO17
   - Owner板 GPIO17 → Servant板 GPIO18
   - 注意：必须交叉连接！
3. ✅ 检查Vive基站
   - 基站是否正常工作
   - 追踪器是否在基站覆盖范围内
4. ✅ 检查Vive开关
   - 通过Web界面确认Vive系统已启用

### 问题2：无法到达目标点

**症状**：
- 机器人无法到达目标点
- 30秒超时后切换到下一个位置

**解决方案**：
1. **检查目标点坐标**
   - 确认坐标是否在Vive坐标系内
   - 确认坐标值是否正确（单位：mm）

2. **调整导航参数**
   ```cpp
   // 在 behavior-vive.ino 中
   const float ANGLE_TOLERANCE = 20.0f;      // 可以增大（更早转向）
   const float DISTANCE_TOLERANCE = 5.0f;    // 可以增大（更容易到达）
   ```

3. **检查障碍物**
   - 使用ToF传感器数据检查路径
   - 调整障碍物避让参数

4. **提高导航速度**
   - 在 `behavior-vive.ino` 的 `gotoPoint()` 函数中增加速度值

### 问题3：导航不稳定

**症状**：
- 机器人来回摆动
- 导航路径不顺畅

**解决方案**：
1. **检查Vive数据更新频率**
   - 应为10Hz（每100ms更新一次）
   - 查看串口输出确认更新频率

2. **调整导航参数**
   - 增大 `ANGLE_TOLERANCE` 可以减少转向频率
   - 调整速度曲线使移动更平滑

3. **检查ToF传感器**
   - 确认传感器工作正常
   - 清洁传感器表面

### 问题4：3位置序列无法完成

**症状**：
- 无法完成所有3个位置
- 在某个位置卡住

**解决方案**：
1. **检查所有位置的坐标配置**
   - 确认3个位置的坐标都已正确配置
   - 确认坐标在Vive坐标系内

2. **增加超时时间**（如果需要）
   ```cpp
   const unsigned long AUTO_NAV_TIMEOUT = 30000;  // 改为更大的值
   ```

3. **检查Vive数据连续性**
   - 确保在整个导航过程中Vive数据有效
   - 如果Vive数据丢失，系统会自动降级为壁障跟随

---

## 🎯 进阶配置

### 自定义3位置序列的目标点

如果需要使用不同的3个位置，可以修改 `owner-4.ino`：

```cpp
// 方式1：直接修改现有坐标
const float TARGET_RED_X = 你的位置1_X;
const float TARGET_RED_Y = 你的位置1_Y;
const float TARGET_BLUE_X = 你的位置2_X;
const float TARGET_BLUE_Y = 你的位置2_Y;
const float TARGET_LOC3_X = 你的位置3_X;
const float TARGET_LOC3_Y = 你的位置3_Y;

// 方式2：添加新的目标点配置（需要修改代码逻辑）
```

### 调整导航精度

```cpp
// 在 behavior-vive.ino 中
const float DISTANCE_TOLERANCE = 10.0f;   // 增大：更容易到达但精度降低
const float DISTANCE_TOLERANCE = 3.0f;    // 减小：精度更高但更难到达
```

### 优化导航速度

```cpp
// 在 behavior-vive.ino 的 gotoPoint() 函数中
float speed = 70.0f;  // 增加基础速度（更快）
// 或
float speed = 30.0f;  // 减小基础速度（更稳定）
```

### 添加更多位置到序列

目前支持3个位置。如需添加更多位置，需要修改代码：

1. 增加 `NUM_LOCATIONS` 常量
2. 添加新的目标点坐标
3. 修改位置选择逻辑

---

## 📝 使用示例

### 示例1：启动3位置序列导航（比赛任务）

```
1. 配置3个位置的坐标
2. 上电系统，等待Vive同步
3. 通过串口发送: V
4. 观察串口输出，等待完成
```

### 示例2：单点导航测试

```
1. 配置目标点坐标（例如红色目标）
2. 通过串口发送: R
3. 机器人自动导航到目标点
4. 到达后自动停止并切换回壁障跟随
```

### 示例3：壁障跟随测试

```
1. 通过串口发送: W
2. 机器人开始壁障跟随
3. 观察机器人跟随右墙移动
4. 可以通过串口发送其他命令切换模式
```

---

## 🔗 相关文件

- `owner-4.ino` - 主控制程序
- `behavior-vive.ino` - Vive导航逻辑
- `behavior-wall.ino` - 壁障跟随逻辑
- `gagac-2/gagac-2.ino` - Servant板程序（Vive数据获取）

---

## 📞 技术支持

如有问题，请检查：
1. 串口输出的错误信息
2. Web界面的Vive数据显示
3. 硬件连接是否正确
4. 配置参数是否合理

---

**最后更新**：2025年
**版本**：1.0
